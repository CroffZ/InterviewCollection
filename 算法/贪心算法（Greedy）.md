# 贪心算法（Greedy）

## 求解思路
* 既然贪心法用于解决最优化问题，所以我们首先对问题进行数学建模，找出其中的：目标函数、约束条件。
* 最优化问题的结果需要用一个n元组来表示，如X=(x1,x2,x3,……,xn)。贪心法的执行一共需要n步，每一步都会确定n元组中的一个元素，并保证每一步选取的值都是局部最优的。在经过n步之后，一共选取了n个值，每个值都是局部最优的，最终我们就可以认为这n个局部最优的值是整体最优的。
* 那么，在每一步中，究竟通过怎样的策略来选取一个当前局部最优解呢？这个选取策略就叫做『最优量度标准』（也叫做贪心准则）。最优量度标准选择的好坏，直接影响最终的结果是不是整体最优。而最优量度标准的选择往往是根据经验来确定的，也就是并不是所有的最优量度标准都能达到整体最优。所以你选取的那个最优量度标准能否导致整体最优，这是需要额外证明的。

## 使用条件
* 要求解的问题是一个最优化问题；
* 这个问题的解可以用n元组表示；
* 该问题满足最优子结构特性；
* 可以找到最优量度标准，并可以证明该最优量度标准能导致一个整体最优解。
* PS：并非对所有最优化问题都能找到最优量度标准，若找不到可以使用动态规划法。

## 常见应用

### 一般背包问题
* 题目描述：有一个背包，最多放Mkg的物体（物体大小不限）；有n个物体，每个物体的重量为Wi，每个物体完全放入背包后可获得收益Pi。问：如何放置能获得最大的收益？
* 注：背包问题分为两种，若每个物体不可分割，则称为0/1背包问题，这种问题无法用贪心法求得最优解，只能求的近似解；而若每个物体可以切分，则称为一般背包问题，可以使用贪心法求的最优解。这里讨论的是一般背包问题。
* 结果集：一般背包问题中，结果集可以用一个n元组表示：x的下标i表示物体的序号；xi表示第i个物体加入背包的部分（0<=xi<=1）
* 目标函数：背包收益的最大值（xi与Pi的乘积和）最大
* 约束条件：物体总重量（xi与Wi的乘积和）不能超过背包容量
* 量度标准：
    * 标准1：重量小的物体优先。将所有物体按照重量递增的顺序排序，每次选重量最小的放入背包。这个量度标准显然无法得到整体最优解，因为重量小的物体并不一定价值高。最优解与价值、重量这两个维度产生关系，而这个量度标准仅考虑了一个维度，因此这样选择并不能导致整体最优解。
    * 标准2：价值高的物体优先。这种选法也无法达到整体最优解，理由同上。
    * 标准3：性价比高的物体优先。首先计算所有物体的性价比（重量和收益的比值），每次优先将性价比高的物体放入背包。这种量度标准考虑了两个维度，可以得到整体最优解。

### 最佳合并模式
* 题目描述：给定n个有序文件，每个文件的记录数分别为wi，请给出一种两两合并的方案，使得总合并次数最少。
* 注意：
    * 外排序算法是将多个有序文件合并成一个有序文件的过程。 
    * 在一次合并的过程中，两个文件中的所有记录都需要先从文件中读入内存，再在内存中排序，最后将排序的结果写入文件中。 
    * 假设两个待排序文件记录数分别为n、m，那么将这两个文件合并成一个有序的文件需要进行n+m次读写。
* 问题转化：
    * n个文件两两合并的过程可以用一棵扩充二叉树来表示。因为扩充二叉树只有度为2或0的节点，没有度为1的节点，这符合两两合并的过程。 
    * 在扩充二叉树中叶节点表示原始文件，非叶结点表示合并过程中的文件，节点的权值表示文件的记录数。
    * n个文件合并过程的总读写次数为带权外路径长度之和，因此，问题就转化为『如何求扩充二叉树的最小加权路径』，可以用哈夫曼算法解决。
* 思路：若要使得带权外路径长度最小，可以将权值大的节点尽量靠近根节点，这样路径短一些；而权值小的节点可以适当远离根节点，因为权值小，外路径稍微长一点也没事。
* 实现步骤：
    1. 用一个优先队列存储所有的初始节点；
    2. 从队列中选出两个权值最小的节点，将它们的和作为它们的根节点，并放入队列中；
    3. 循环这个过程，直到队列中只有一个节点为止，此时具有最小带权路径的扩充二叉树构造完毕！此时带权外路径长度即为最小的读写次数。

### 最小代价生成树
* 题目描述：n个村庄间架设通信线路，每个村庄间的距离不同，如何架设最节省开销？
* 问题分析：这个问题中，村庄可以抽象成节点，村庄之间的距离抽象成带权值的边，要求最节约的架设方案其实就是求如何使用最少的边、最小的权值和将图中所有的节点连接起来。这就是一个最小代价生成树的问题，可以用Prim算法或kruskal算法解决。
* 参考：图（Graph）。

### 单源最短路径
* 题目描述：给一个有向无环带权图，并给一个起点，求出该原点到所有顶点的最短路径。
* 问题分析：使用Dijkstra算法。
* 参考：图（Graph）。

### 跳格子
* 题目描述：给一个非负整数数组，数组里的每个元素表示从该位置可以跳出的最远距离，要求问从第一个元素（index=0）开始，能否达到数组的最后一个元素。
* 问题分析：所以这里可以使用贪心算法，计算出到某个点时能够跳出的最大距离（当前的最大值和（当前点+能跳出的最大距离）的较大的值），如果能跳出的最大距离大于最后一个点的位置，那么能到达最后一个元素；如果到达当前点后，不能在往后跳，那么不能达到最后点，返回false（通常是当前点的数字为0且前面的点所能到达的最大值点就是当前点）。


