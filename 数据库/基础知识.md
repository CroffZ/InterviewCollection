# 基础知识

## 数据库范式

### 范式级别

#### 第一范式（1NF）
* 要求：强调每一列的原子性，即每一列都不能再拆分。
* 举例：地址中包含省份名和城市名，如果这两项需要单独处理，则不满足1NF，需要将地址列拆分成两列。

#### 第二范式（2NF）
* 要求：在满足1NF的基础上，表必须包含主键，并且没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分。
* 举例：设计一个订单表（订单编号，下单时间，商品编号，商品名称，商品单价，商品数量），将订单编号和商品编号作为联合主键，这样一来，表中商品名称和商品单价仅仅依赖于商品编号，没有完全依赖主键，违反了2NF，需要拆分为商品表（商品编号，商品名称，商品单价）和订单表（订单编号，下单时间，商品编号，商品数量）。

#### 第三范式（3NF）
* 要求：在满足2NF的基础上，非主键列必须直接依赖于主键，不能存在传递依赖。
* 举例：设计一个学生表（学号，姓名，年龄，所在学院，学院地点，学院电话），其中学院地点和学院电话依赖于所在学院，所在学院又依赖于学号，构成传递依赖，不符合3NF，需要拆分为学生表（学号，姓名，年龄，所在学院）和学院表（学院名称，学院地点，学院电话）。

### 使用范式的好处
* 减少数据冗余。
* 避免插入异常、修改异常和删除异常。

## 数据库索引
索引是在表的列上创建的，用来存储该列的值的一种数据结构，常用的索引包括B树索引、B+树索引和Hash索引。

### 索引的实现原理
包括B树索引、B+树索引和Hash索引。

#### B树索引
* B树是平衡多路查找树，相对于二叉树，B树每个结点有多个分支，层数相对比较少，可以缩短搜索路径。
* 每个结点都包含了索引字段的键值，成功搜索一个对象可能不需要到达树的叶结点。
* 成功搜索包括沿路径搜索和结点内搜索，成功搜索时间取决于目标结点所在的层次和结点内键值数量。

#### B+树索引
* B+树是B树的变种，也是一种多叉树，但它的所有叶结点都在同一层。
* 所有非叶结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。
* 所有叶结点中包含满足相应查询路径条件约束的全部关键字，按照从小到大的顺序链接。

#### Hash索引
* 使用Hash表来存储数据，大多使用链表法解决冲突。
* 检索数据的时间复杂度可以达到O(1)，取决于冲突的数据量。
* 比较适合等式比较的操作，不能加速排序，也不能加速范围查找，只能使用整个关键字来搜索一行。

### B+树比B树更适合用于文件索引和数据库索引的原因
* 由于局部性原理，B+树的结点比B树小，同一盘块中容纳的关键字数量更多，一次性读入内存的关键字更多，可以减少读取磁盘次数。
* B+树所有关键字的查询路径长度基本相同，因此查询效率更稳定。
* B+树范围查询很容易，直接从叶结点挨个儿扫一遍就行，B树还得中序遍历所有结点，效率太低。

### 聚集索引和非聚集索引

#### 聚集索引
* 表中数据根据聚集索引的数据结构来组织。
* 比如原来表的数据是一行一行整齐放在磁盘上，用了B树聚集索引后表的数据就变成树状存放在磁盘上。

#### 非聚集索引
* 和聚集索引一样采用树或Hash的数据结构来维护，各结点的值为索引字段的值。
* 如果给表中多个字段加上非聚集索引，就会出现多个独立的索引结构，它们相互之间不存在关联。
* 每次给字段新建一个索引，字段中的数据就会被复制一份出来生成索引结构，所以会增大表的体积。

#### 二者比较
通过聚集索引可以直接查到需要的数据，而通过非聚集索引需要先查到记录对应的主键值，再根据主键值通过聚集索引查到需要的数据。（参考：[深入浅出数据库索引原理](https://zhuanlan.zhihu.com/p/23624390)）

#### 主键和聚集索引的区别
主键是一种唯一索引，它可以是聚集索引，也可以是非聚集索引。大多数数据库创建主键时，都会自动创建主键的聚集索引。

### 索引的优点和缺点

#### 优点
* 通过创建唯一性索引，可以保证表中每一行数据的唯一性。
* 可以大大加快数据的检索速度。
* 可以加速表和表之间的连接。
* 可以减少对检索结果进行分组和排序的时间。

#### 缺点
* 创建索引需要额外的时间和空间开销。
* 修改表中数据时也要同时维护索引，降低了数据维护速度。

### 索引的使用场景
* 在经常需要检索的列上创建索引，可以加快检索的速度。
* 在作为主键的列上创建索引，可以强制该列的唯一性和组织表中数据的结构。
* 在经常用作外键的列上创建索引，可以加快表连接的速度。
* 在经常需要排序的列上创建索引，因为索引已排序，可以加快排序查询时间。
* 在经常需要根据范围搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的。
* 在经常用在where子句中的列上创建索引，可以加快条件判断速度。

## 数据库事务
* 一个事务通常包含对数据库或读或写的一个操作序列，提交时可以确保事务中所有操作都依次成功执行，如果其中某个操作不能完成，则该事务中所有操作都要被回滚，即要么全部执行，要不都不执行。
* 多个事务同时执行时，相互之间没有关联，每个事务都能独立运行。
* 为了实现回滚功能，通常需要维护一个事务日志来追踪事务中的操作。

### 事务的四大特性：ACID
* 原子性（Atomic）：事务作为一个整体被执行，其中的数据库操作要么全部执行，要么都不执行。
* 一致性（Consistency）：确保事务执行之后数据库的数据从一个一致状态转变为另一个一致状态，而不可能会出现中间的过程态。
* 隔离性（Isolation）：多个事务并发执行时，一个事务的执行不能影响其他事务的执行，提供多种隔离级别。
* 持久性（Durability）：已被提交的事务中对数据库的修改应该永久被保存在数据库中。

### 事务存在的三个问题
* 脏读：事务A对数据作了修改但还没提交，这时事务B访问并使用了这个数据，因为事务A还没有提交，所以事务B读到的是脏数据。
* 不可重复读：在同一事务中，两次读取同一数据，得到的数据内容不同，这是因为在该数据在两次读取期间被另一个事务修改并提交了。
* 幻读（虚读）：在同一事务中，用同一操作两次读取，得到的记录数不同，这是因为在两次读取期间被另一个事务添加或删除了某些记录并提交了。

### 事务的四大隔离级别
* 可串行化（Serializable）：最高的隔离级别，可以解决幻读问题。读数据加表级锁，事务结束后释放；写数据加表级锁，事务结束后释放。不会发生脏读、不可重复读和幻读。
* 可重复读（Repeatable reads）：可以解决不可重复读现象。读数据加行级锁，事务结束后释放；写数据加行级锁，事务结束后释放。可能发生幻读，不会发生脏读和不可重复读。
* 提交读（Read committed）：只能读到其他事务已经提交的操作修改的数据。读数据加行级锁，读完该行就释放；写数据加行级锁，事务结束后释放。可能发生不可重复读和幻读，不会发生脏读。
* 未提交读（Read uncommitted）：最低的隔离级别，可能读到其他事务中未提交的操作修改的数据。读数据不加锁；写数据加行级锁，写完该行就释放。可能发生脏读、不可重复读和幻读。

### JDBC对事务的支持
* JDBC中Connection的auto-commit属性可以指定事务的粒度，默认为true：
    * 当auto-commit为true时，每条SQL语句执行完毕后立即自动提交事务；
    * 当auto-commit为false时，每个事务都必须显式调用`commit()`方法进行提交，或者显式调用`rollback()`方法进行回滚。
* JDBC中Connection的`setTransactionIsolation()`方法设置事务的隔离级别。

```java
try {
    conn.setAutoCommit(false); // 将自动提交设置为false
    ps.executeUpdate("修改SQL"); // 执行修改操作
    ps.executeQuery("查询SQL");  // 执行查询操作
    conn.commit(); // 当两个操作成功后手动提交
} catch (Exception e) {
    conn.rollback(); // 一旦有操作出错就回滚
}
```

## 数据库优化（主要针对MySQL）

### SQL语句优化
* 优化insert语句，一次插入多行数据。
* 尽量避免在where子句中使用!=或<>操作符，否则引擎将放弃使用索引而改为全表扫描。
* 尽量避免在where子句中对字段进行null值判断，否则引擎将放弃使用索引而改为全表扫描。
* 优化嵌套查询和表连接操作。
* 很多时候用exists代替in是一个好的选择。

### 索引的优化
* 索引的使用场景：参考数据库索引部分。
* 索引失效的情形：
    * 模糊匹配：以%（表示任意0个或多个字符）开头的like语句。
    * or语句前后没有同时使用索引。
    * 对于多列联合索引，必须满足最左匹配原则。

### 表结构优化
* 选择合适的数据类型：
    * 尽可能使用较小的数据类型解决问题，减少占用空间。
    * 尽可能使用简单的数据类型，比如MySQL处理int要比varchar容易。
    * 尽可能使用not null定义字段，可以提高数据完整性。
    * 尽量避免使用text类型，可以使用varchar来替换，非用不可时可以考虑分表。
* 范式优化：一般情况下，表的设计应该遵循三大范式，不过也有需要打破范式的情况。
* 表的垂直拆分：
    * 把含有多个列的表拆分成多个表，用于解决表宽度问题。
    * 包括几种拆分手段：把不常用的字段单独放到同一个表；把经常使用的字段放到同一个表；把大字段独立放入一个表。
    * 好处：拆分后业务清晰，而且聚集索引中每个项可以占用更少空间。
* 表的水平拆分：
    * 把数据平分到多个表中存储，用于解决表中数据过多的问题。
    * 拆分后的每个表结构一致，平分数据的常用方法有mod和hash法。
    * 水平拆分会带来一些问题，包括跨分表的查询、统计等，但也有好处，比如可以降低查询时需要读的数据量，减少索引层数。
* 缓存表：
    * 可以用一张缓存表来保存经常访问的数据，每次对数据的请求先在缓存表查，查不到再到整张表中查。
    * 相当于cache，常用于一张表的数据很多但其中经常访问的数据很少的情况。

## 常考点

### 存储过程（Stored Procedure）
* 存储过程是一个事先编译好并存储在数据库的一段SQL语句的代码块，就像一个函数一样实现一些功能，然后再给这个代码块取个名字，以后再用到这个功能的时候直接调用。
* 优点：
    * 存储过程只在创建时进行编译，以后每次执行都不需再重新编译，执行效率高。
    * 存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。
    * 通过存储过程能够使没有权限的用户间接地存取数据库，从而确保安全性。
    * 当SQL语句有变动时，可以只修改数据库中的存储过程而不必修改代码，减少工作量。
* 缺点：调试麻烦，移植性差。

### 视图（View）
* 视图是一种虚拟的表，通常是有一个表或者多个表的行或列的子集，具有和物理表相同的功能，可以对视图进行增，删，改，查等操作，但对视图的修改不影响原表。
* 用途：
    * 可以只暴露一张表的部分字段给访问者。
    * 可以用统一的方式查询来源于不同表的数据。

### 游标（Cursor）
* 游标是一种能从含有多条数据的结果集中每次提取一条的机制，可以充当指针，它可以指定结果中的任何位置，然后允许用户对指定位置的数据进行处理。
* 游标提供了逐行操作表中数据的方法，可以一次一行或多行地前进或后退。

### 触发器（Trigger）
* 触发器是一种特殊类型的，与表相关联的存储过程，它不由用户直接调用，而是在相应表中数据发生变化时自动调用，常常用于强制业务规则和数据完整性。
* 触发器可以包含复杂的Transaction-SQL语句：将触发器和触发它的语句作为可在触发器内回滚的单个事务对待。
* 触发器的种类：
    * 数据操纵语言（DML，Data Manipulation Language）触发器：是指触发器在数据库中发生DML事件时启用，其中DML事件指在表或视图中修改数据的INSERT、UPDATE、DELETE语句。
    * 数据定义语言（DDL，Data Definition Language）触发器：是指当服务器或数据库中发生DDL事件时启用，其中DDL事件指在表或索引中的CREATE、ALTER、DROP语句。
    * 登陆触发器：是指当用户登录SQL Server，并建立会话时触发。

### 约束（Constraint）
* 主键约束（Primary Key）：用于设置主键，保证唯一性和非空性。
* 唯一约束（Unique）：保证唯一性，可以为空，但只能有一个。
* 默认约束（Default）：表示该字段数据的默认值。
* 外键约束（Foreign Key）：用于设置外键，建立两表间的连接关系。
* 非空约束（Not Null）：用于设置非空约束，该字段不能为空。

### 乐观锁和悲观锁
悲观锁与乐观锁是两种常见的资源并发锁设计思路。

#### 悲观锁
* 悲观锁是指先获取锁，再进行业务操作，即“悲观”的认为所有的操作均会导致并发安全问题，因此要先确保获取锁成功再进行业务操作。
* 常用`SELECT … FOR UPDATE`操作来实现悲观锁，但需要数据库提供支持，因此不是所有数据库都能用。
* 当数据库执行`SELECT … FOR UPDATE`时，会获取select结果集中每一行的行锁，因此其他并发执行的`SELECT … FOR UPDATE`如果试图选中同一行则会阻塞，需要等待行锁被释放，而这些行锁会在当前事务结束时自动释放，因此必须在事务中使用。
* 这里需要特别注意的是，不同的数据库对`SELECT … FOR UPDATE`的支持有所区别，例如Oracle支持的是`SELECT … FOR UPDATE NO WAIT`，表示如果拿不到锁立刻报错，而不是阻塞等待，但MySQL就没有`NO WAIT`这个选项。
* 另外，MySQL中`SELECT … FOR UPDATE`语句执行时，所有扫描过的行都会被锁上。所以在MySQL中用悲观锁时，务必要确定使用了索引，而不是全表扫描。

#### 乐观锁
* 乐观锁是指先进行业务操作，只在最后实际更新数据时进行检查数据是否被更新过，若未被更新过，则更新成功；否则，失败重试。
* 乐观锁在数据库上的实现完全是逻辑的，不需要数据库提供特殊的支持，一般的做法是在需要锁的数据上增加一个版本号或者时间戳，然后按照如下方式实现：

```sql
SELECT data AS old_data, version AS old_version FROM table;
UPDATE SET data = new_data, version = new_version WHERE version = old_version;
if (updated row > 0) {
    // 乐观锁获取成功，操作完成
} else {
    // 乐观锁获取失败，回滚并重试
}
```

* 乐观锁不一定要在事务中，因为数据库每次执行一条UPDATE语句时会获取该行的互斥写锁，直到这一行被成功更新后才释放。所以可以认为UPDATE操作是一个原子操作，需要排除的只是在SELECT原版本号和UPDATE操作之间出现的并发修改情况，通过版本号或时间戳就可以解决。

#### 应用场景
* 一般情况下，读多写少更适合用乐观锁，读少写多更适合用悲观锁。
* 乐观锁在不发生取锁失败的情况下，开销比悲观锁小，但是一旦发生失败就需要回滚，开销比较大。因此乐观锁适合用在资源竞争不激烈的场景，而悲观锁适合用在资源竞争激烈的场景。

### MVCC机制
* 概念：MVCC，Multiple Version Concurrent Control，多版本并发控制，是一种乐观锁的实现方法，可以实现低代价的无锁并发。
* 实现：为每个事务分配单向增长的版本号，从而为每个事务修改保存一个版本，读操作只读事务开始前的版本号，在事务结束后再次读取版本号，如果一致则认为没有并发操作发生，直接提交事务；如果不一致则认为有并发操作已提交修改，需要回滚事务后重试。
* 好处：读操作不需要阻塞写操作，写操作也不需要阻塞读操作，同时还可以避免脏读和不可重复读。

### delete、truncate和drop命令的区别
* delete命令：用来删除表的全部或某些数据行，会触发这个表上所有的delete触发器。执行delete之后，用户需要提交或回滚来执行删除或撤销删除。
* truncate命令：用来删除表中所有数据，这个操作不能回滚，也不会触发这个表上的触发器，比不带where的delete命令删除所有数据更快，且使用事务日志的资源更少。
* drop命令：用来删除整张表和其中的所有数据、索引和权限，这个操作不能回滚，也不会触发这个表上的触发器。

### 超键、候选键、主键和外键的区别
* 超键：在关系中能唯一标识元组的属性集称为超键，一个属性或多个属性组合在一起都可以作为一个超键。
* 候选键：最小超键，即元组不能再少了，再少就不是超键了。
* 主键：数据库表中可以唯一标示每个存储对象的超键。一张表只能有一个主键，且主键不能为空值。
* 外键：在表A中存在的表B的主键，称该键为表B在表A中的外键。

### 关系型数据库和非关系型数据库的区别

#### 关系型数据库
* 概念：关系型数据库是指采用了关系模型来组织数据的数据库，即二维表格模型。
* 优点：
    * 二维表结构贴近逻辑世界，相对于网状结构、层次结构等其他模型来说更容易理解。
    * 通用的SQL语言使得操作关系型数据库十分方便。
    * 实体完整性、参照完整性和用户定义的完整性可以减少数据冗余。
* 瓶颈：
    * 在高并发读写需求中，磁盘I/O是一个很大的瓶颈。
    * 在一张包含海量数据的表中查询效率很低。
    * 数据库的表结构难以升级和扩展。
* 典型代表：MySQL和Oracle。

#### 非关系型数据库NoSQL
* 概念：与关系型数据库相对，非关系型数据库是指不使用关系结构来组织数据、且一般不遵循ACID的数据存储系统。
* 理念：非关系型数据库提出另一种组织数据的方式，比如键值对存储，而且结构不固定，比如每个存储对象可以有不同的属性，可以根据自己的需要添加自定义的键值对，这样就可以不局限于固定的结构，减少查询开销。相对地，由于约束少了，非关系型数据库难以体现设计的完整性。
* 分类：
    * 面向高性能读写的key-value数据库：有极高的并发读写性能，主要代表是Redis。
    * 面向海量数据访问的文档数据库：可以在海量数据中快速查找数据，主要代表为MongoDB。
    * 面向可扩展性的分布式数据库：可以解决传统数据库存在的可扩展性缺陷，可以适应数据量的增加以及数据结构的变化。

#### 二者使用场景区别
* 事务的一致性：关系型数据库适用于所有对一致性有要求的系统，如银行系统；非关系型数据库适用于对一致性要求不太严格的应用，比如网页应用，两个人看到同一好友的数据更新时间相差几秒是可以容忍的。
* 读写性能：因为维护一致性付出的代价就是读写性能差，像微博这样的应用是无法忍受的，因此需要使用非关系型数据库。
* 可扩展性：关系型数据库具有固定的表结构，可扩展性很差，难以应付系统升级、功能增加而带来的数据结构变动，因此需要使用非关系型数据库。

### 常见的聚合函数
* `count(*)`：统计表中所有记录的个数。
* `count(列名)`：统计一列中所有值的个数，重复值也会被当作有效的记录。
* `count(distinct 列名)`：统计一列中所有值的个数，其中重复的记录只会被记录一次。
* `sum(列名)`：计算一列值的总和。
* `avg(列名)`：计算一列值的平均值。
* `max(列名)`：找出一列值中的最大值。
* `min(列名)`：找出一列值中的最小值。
