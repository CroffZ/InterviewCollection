# 常用数据库

## MySQL
一种开源的关系型数据库，使用SQL进行数据库管理。

### MySQL的存储引擎：MyISAM和InnoDB
MyISAM由早期的ISAM（Indexed Sequential Access Method，有索引的顺序访问方法）改良，虽然性能极佳，但它有一个显著的缺点：不支持事务处理，因此MySQL引入了另一种引擎InnoDB，它可以支持ACID兼容的事务功能，可以强化参考完整性与并发违规处理机制，后来就逐渐取代MyISAM。

#### 存储结构
* 每个MyISAM表在磁盘上存储成三个文件，分别存储表定义、数据文件和索引文件。
* 而InnoDB所有的表都保存在同一个数据文件中，也可能是多个文件，或者是独立的表空间文件，InnoDB表的大小只受限于操作系统文件的大小，一般为2GB。

#### 存储空间
* MyISAM可被压缩，占据的存储空间较小，支持静态表、动态表、压缩表三种不同的存储格式。
* InnoDB需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引。

#### 可移植性：备份及恢复
* MyISAM的数据是以文件的形式存储，所以数据转移很方便，在备份和恢复时也可单独对某个表进行操作。
* InnoDB免费的方案可以是拷贝数据文件、备份，或者用`mysqldump`命令，在数据量大时相对麻烦。

#### 事务支持
* MyISAM强调性能，每次查询具有原子性，其执行速度比InnoDB类型更快，但是不提供事务支持。
* InnoDB提供事务、外键等高级数据库功能，具有事务提交、回滚和崩溃修复能力，支持四种隔离级别。

#### 锁机制
* MyISAM只支持表级锁，用户在操作MyISAM表时，`SELECT`、`UPDATE`、`DELETE`和`INSERT`语句都会给表自动加锁。
    * 表共享读锁：不会阻塞其他用户对同一表的读操作，但会阻塞写操作。
    * 表独占写锁：会阻塞其他用户对同一表的读和写操作。
* InnoDB支持事务和行级锁，可以大幅提高并发性能，但是InnoDB的行锁只对WHERE子句中的主键有效，非主键的WHERE会锁全表。
    * 行共享锁：允许一个事务去读一行，阻止其他事务获得相同数据集的行排他锁。用`SELECT ... IN SHARE MODE`可以获取行共享锁。
    * 行排他锁：允许一个事务更新数据，阻止其他事务获得相同数据集的行共享锁和行排他锁。用`SELECT ... FOR UPDATE`可以获取行排他锁。
* InnoDB的间隙锁（Next-Key锁）
    * 概念：当检索范围数据并请求共享或排他锁时，InnoDB会给符合条件的数据的索引项加锁，间隙是指键值在条件范围内但并不存在的记录，InnoDB也会对这些记录加锁。
    * 举例：假如item表中有10条记录，其id的值分别是1到10，查询语句`SELECT * FROM item WHERE id > 9 FOR UPDATE`是一个范围条件的检索，InnoDB不仅会对符合条件的id值为10的记录加锁，也会对id大于10（这些记录并不存在）的“间隙”加锁。
    * 注意事项：InnoDB使用间隙锁的目的是防止幻读，以满足相关隔离级别的要求，但会阻塞符合条件范围内键值的并发插入，这往往会造成严重的锁等待。

#### 索引和主键
* MyISAM允许没有任何索引和主键的表存在，所有索引都是非聚集索引。
* InnoDB中如果没有设定主键或者非空唯一索引，就会自动生成一个用户不可见的主键，主索引是聚集索引，其他索引是非聚集索引。

#### 外键
MyISAM不支持外键，而InnoDB支持外键。

### MySQL中char、varchar和text的区别

#### char(n)
* 存储定长字符串，可以指定默认值，索引效率非常高，必须在括号里定义长度n，超过会被截断，n的最大值是255。
* n也是存储空间的实际长度，不管实际字符串有多长，都会占用n个字符的空间，后面会用空格填充，如果原数据末尾就存在空格，检索取出时会丢失。

#### varchar(n)
* 存储变长字符串，可以指定默认值，存储效率没有char(n)高，可以在括号里定义长度n，超过会被截断，所以实际可以保存的最大字符串长度是n-1，因为在字符串被截断时，会留一个空间保存字符串结束的标记。
* 保存数据的时候不进行空格自动填充，而且如果数据存在空格，保存和检索时尾部的空格仍会保留。
* varchar(n)可以指定的长度上限是65535字节，但实际情况会有1-3个字节存储字符串的长度信息，所以实际可以保存的字符串的最大长度为65532字节。

#### text 
* text是用来存储较长字符串的结构，其存储原理与varchar(n)相同，效率也相似。
* text与varchar(n)的区别主要是：text不能限定最大长度n，也不能指定默认值，而且使用外部存储来存储字符长度，不占用字符串空间，最大支持字符串长度为65535个字节。

### MySQL的慢查询日志
* MySQL的慢查询日志用来记录响应时间超过阀值的查询操作，通过该日志可以找出有问题的SQL语句。
* 相关参数：
    * slow_query_log：是否开启慢查询日志。
    * long_query_time：慢查询阀值，当查询时间多于设定的阀值时，记录日志。
    * log_queries_not_using_indexes：未使用索引的查询也被记录到慢查询日志中。
    * log_output：日志存储方式，可以文件形式存储，也可以存入数据库，还可以两者同时启用。

### MySQL的explain命令
* MySQL的explain命令用于查看执行查询效果，展示了MySQL如何使用索引来处理select语句以及连接表，可以帮助选择更好的索引和写出更优化的查询语句。
* 使用方法：在select语句前加上explain，如explain select * from user;。
* 结果中每一列的解释：
    * id：表示select查询序列号，代表SQL语句执行的顺序。
    * select_type：表示查询类型，包括simple、primary、union、dependent union和union result。
    * table：表示该行数据是关于哪张表的。
    * type：表示连接使用了什么类型，从好到坏依次为const、eq_reg、ref、range、index和ALL。
    * possible_keys：表示可能应用在这张表中的索引，如果为空则表示没有可用的索引。
    * key：表示查询中实际使用的索引，如果为空则表示没有使用索引。
    * key_len：表示使用的索引的长度，在不损失精确性的情况下，长度越短越好。
    * ref：表示索引的哪一列被使用了，如果可能的话是一个常数。
    * rows：表示返回查询结果必须检查的数据行数，数值越大越不好，说明没有用好索引。
    * extra：表示MySQL如何解析查询的额外信息。

## Redis
* Redis是一个基于内存的key-value存储系统，读取效率极高，提供多种语言的API，常被用作缓存。
* Redis是单进程单线程的，利用队列技术将并发访问变为串行访问，消除了传统数据库并行控制的开销（上下文切换）。
* Redis支持事务，具有事务的四大特性ACID，操作都是原子性，还可以对存入的Key-Value设置expire时间，因此也可以被当作一个功能加强版的Memcache来用。

### Redis支持的数据类型
* String：字符串，这个没啥好说的。
* List：有序、可重复的列表，可以做简单的消息队列。
* Set：无序、不可重复的集合，提供交集、并集、差集等操作。
* SortedSet：排序的不可重复的集合，基于权重参数score进行排列。
* Hash：结构化的对象，可以操作其中的某个字段，类似JSON。

### Redis的数据淘汰策略
* Redis采用定期删除+惰性删除策略：
    * 定期删除：Redis默认每隔100ms，抽取随机的数据集进行检查并删除过期的key，所以如果只采用定期删除策略，会导致很多key到时间没有删除。
    * 惰性删除：当获取某个key时，Redis会检查该key是否过期，如果过期了就会自动删除。
* 上述两种策略存在问题：定期删除中没删除的key，也没有及时去获取它，它就会一直在内存中不会被清理，可以采用内存淘汰机制来解决这个问题，在redis.conf文件中配置。
    * volatile-lru：当内存不足以容纳新写入数据时，从过期数据集中挑选最近最少使用的数据淘汰。
    * volatile-ttl：当内存不足以容纳新写入数据时，从过期数据集中挑选将要过期的数据淘汰。
    * volatile-random：当内存不足以容纳新写入数据时，从过期数据集中随机选择数据淘汰。
    * allkeys-lru：当内存不足以容纳新写入数据时，从所有数据集中挑选最近最少使用的数据淘汰。
    * allkeys-random：当内存不足以容纳新写入数据时，从所有数据集中随机选择数据淘汰。
    * no-enviction：当内存不足以容纳新写入数据时，新写入操作会报错。

### Redis与Memcache的区别
* 数据类型：Memcache的值都是简单的字符串，而Redis支持丰富的数据类型。
* 数据大小：Memcache单个value的最大限制是1MB，而Redis单个value的最大限制是1GB。
* 存储方式：Memcache把数据全部存在内存之中，断电后会挂掉，而且数据不能超过内存大小，而Redis则是主要数据存在内存，部分数据存在磁盘上，定期将内存数据flush进磁盘，可以实现数据的持久化存储。
* 底层模型：Redis直接自己构建了虚拟内存机制，而Memcache使用一般的系统调用，这会浪费一定的时间去移动和请求，因此Redis的读写速度比Memcache快。

### 缓存穿透问题和缓存雪崩问题

#### 缓存穿透问题
* 缓存穿透，即黑客故意去请求缓存中不存在的数据，导致所有的请求都怼到数据库上，从而数据库连接异常。
* 解决方案：
    * 利用互斥锁，缓存失效的时候，先去获得锁，得到锁再请求数据库；没得到锁则休眠一段时间重试。
    * 采用异步更新策略，无论key是否取到值，都直接返回。value值中维护一个缓存失效时间，缓存如果过期，异步起一个线程去读数据库，更新缓存。需要做缓存预热，即项目启动前，先加载缓存。
    * 提供一个能迅速判断请求是否有效的拦截机制，比如利用布隆过滤器，内部维护一系列合法有效的key，可以迅速判断出，请求所携带的Key是否合法有效，如果不合法，则直接返回。

#### 缓存雪崩问题
* 缓存雪崩，即缓存同一时间大面积的失效，这个时候又来了一波请求，结果请求都怼到数据库上，从而导致数据库连接异常。
* 解决方案：
    * 给缓存的失效时间，加上一个随机值，避免集体失效。
    * 使用互斥锁，但是该方案吞吐量明显下降了。
    * 使用双缓存，假设为缓存A和缓存B，缓存A的失效时间为20分钟，缓存B不设失效时间，自己做缓存预热操作，操作细节如下：
        1. 从缓存A读数据库，有则直接返回；
        2. 如果A没有数据，则直接从B读数据，直接返回，并且异步启动一个更新线程；
        3. 更新线程同时更新缓存A和缓存B。

### Redis分布式存储
* Redis支持主-从的分布式存储模式：主数据库Master和从数据库Slave。
* Master会将数据同步到Slave，而Slave不会将数据同步到Master。
* Slave启动时会连接Master来同步数据。

#### 读写分离模型
* 利用Master来插入数据，Slave提供检索服务，这样可以有效减少单个机器的并发访问数量。
* 通过增加Slave的数量，读的性能可以线性增长；为了避免Master的单点故障，集群一般都会采用两台Master做双机热备。所以整个集群的读和写的可用性都非常高。
* 读写分离模型的缺陷在于，不管是Master还是Slave，每个节点都必须保存完整的数据。如果在数据量很大的情况下，集群的扩展能力还是受限于单个节点的存储能力。

#### 数据分片模型
* 将每个节点看成都是独立的Master，然后通过业务实现数据分片。
* 为了解决读写分离模型的缺陷，可以使用数据分片模型。

### Redis备份策略
Redis提供两种备份方法：RDB和AOF。

#### RDB持久化
* RDB是在某个时间点将内存中的所有数据的快照保存到磁盘上，在数据恢复时，可以恢复备份时间以前的所有数据，但无法恢复备份时间点后面的数据。
* 默认情况下Redis在磁盘上创建二进制格式的命名为dump.rdb的数据快照，可以通过配置文件配置每隔N秒且数据集上至少有M个变化时创建快照，还可以配置是否对数据进行压缩、快照名称、存放快照的工作目录。

#### AOF持久化
* AOF是以协议文本的方式，将所有对数据库进行过写入的命令（及其参数）记录到 AOF 文件，以此达到记录数据库状态的目的。
* 优点是基本可以实现数据无丢失（缓存的数据有可能丢失），缺点是随着数据量的持续增加，AOF文件也会越来越大。


