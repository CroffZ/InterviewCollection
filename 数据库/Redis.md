# Redis
* Redis是一个基于内存的key-value存储系统，读取效率极高，提供多种语言的API，常被用作缓存。
* Redis是单进程单线程的，利用队列技术将并发访问变为串行访问，消除了传统数据库并行控制的开销（上下文切换）。
* Redis支持事务，具有事务的四大特性ACID，操作都是原子性，还可以对存入的Key-Value设置expire时间，因此也可以被当作一个功能加强版的Memcache来用。

## Redis支持的数据类型
* String：字符串，这个没啥好说的。
* List：有序、可重复的列表，可以做简单的消息队列。
* Set：无序、不可重复的集合，提供交集、并集、差集等操作。
* SortedSet：排序的不可重复的集合，基于权重参数score进行排列。
* Hash：结构化的对象，可以操作其中的某个字段，类似JSON。

## Redis的数据淘汰策略
* Redis采用定期删除+惰性删除策略：
    * 定期删除：Redis默认每隔100ms，抽取随机的数据集进行检查并删除过期的key，所以如果只采用定期删除策略，会导致很多key到时间没有删除。
    * 惰性删除：当获取某个key时，Redis会检查该key是否过期，如果过期了就会自动删除。
* 上述两种策略存在问题：定期删除中没删除的key，也没有及时去获取它，它就会一直在内存中不会被清理，可以采用内存淘汰机制来解决这个问题，在redis.conf文件中配置。
    * volatile-lru：当内存不足以容纳新写入数据时，从过期数据集中挑选最近最少使用的数据淘汰。
    * volatile-ttl：当内存不足以容纳新写入数据时，从过期数据集中挑选将要过期的数据淘汰。
    * volatile-random：当内存不足以容纳新写入数据时，从过期数据集中随机选择数据淘汰。
    * allkeys-lru：当内存不足以容纳新写入数据时，从所有数据集中挑选最近最少使用的数据淘汰。
    * allkeys-random：当内存不足以容纳新写入数据时，从所有数据集中随机选择数据淘汰。
    * no-enviction：当内存不足以容纳新写入数据时，新写入操作会报错。

## Redis与Memcache的区别
* 数据类型：Memcache的值都是简单的字符串，而Redis支持丰富的数据类型。
* 数据大小：Memcache单个value的最大限制是1MB，而Redis单个value的最大限制是1GB。
* 存储方式：Memcache把数据全部存在内存之中，断电后会挂掉，而且数据不能超过内存大小，而Redis则是主要数据存在内存，部分数据存在磁盘上，定期将内存数据flush进磁盘，可以实现数据的持久化存储。
* 底层模型：Redis直接自己构建了虚拟内存机制，而Memcache使用一般的系统调用，这会浪费一定的时间去移动和请求，因此Redis的读写速度比Memcache快。

## 缓存穿透问题和缓存雪崩问题

### 缓存穿透问题
* 缓存穿透，即黑客故意去请求缓存中不存在的数据，导致所有的请求都怼到数据库上，从而数据库连接异常。
* 解决方案：
    * 利用互斥锁，缓存失效的时候，先去获得锁，得到锁再请求数据库；没得到锁则休眠一段时间重试。
    * 采用异步更新策略，无论key是否取到值，都直接返回。value值中维护一个缓存失效时间，缓存如果过期，异步起一个线程去读数据库，更新缓存。需要做缓存预热，即项目启动前，先加载缓存。
    * 提供一个能迅速判断请求是否有效的拦截机制，比如利用布隆过滤器，内部维护一系列合法有效的key，可以迅速判断出，请求所携带的Key是否合法有效，如果不合法，则直接返回。

### 缓存雪崩问题
* 缓存雪崩，即缓存同一时间大面积的失效，这个时候又来了一波请求，结果请求都怼到数据库上，从而导致数据库连接异常。
* 解决方案：
    * 给缓存的失效时间，加上一个随机值，避免集体失效。
    * 使用互斥锁，但是该方案吞吐量明显下降了。
    * 使用双缓存，假设为缓存A和缓存B，缓存A的失效时间为20分钟，缓存B不设失效时间，自己做缓存预热操作，操作细节如下：
        1. 从缓存A读数据库，有则直接返回；
        2. 如果A没有数据，则直接从B读数据，直接返回，并且异步启动一个更新线程；
        3. 更新线程同时更新缓存A和缓存B。

## Redis分布式存储
* Redis支持主-从的分布式存储模式：主数据库Master和从数据库Slave。
* Master会将数据同步到Slave，而Slave不会将数据同步到Master。
* Slave启动时会连接Master来同步数据。

### 读写分离模型
* 利用Master来插入数据，Slave提供检索服务，这样可以有效减少单个机器的并发访问数量。
* 通过增加Slave的数量，读的性能可以线性增长；为了避免Master的单点故障，集群一般都会采用两台Master做双机热备。所以整个集群的读和写的可用性都非常高。
* 读写分离模型的缺陷在于，不管是Master还是Slave，每个节点都必须保存完整的数据。如果在数据量很大的情况下，集群的扩展能力还是受限于单个节点的存储能力。

### 数据分片模型
* 将每个节点看成都是独立的Master，然后通过业务实现数据分片。
* 为了解决读写分离模型的缺陷，可以使用数据分片模型。

## Redis备份策略
Redis提供两种备份方法：RDB和AOF。

### RDB持久化
* RDB是在某个时间点将内存中的所有数据的快照保存到磁盘上，在数据恢复时，可以恢复备份时间以前的所有数据，但无法恢复备份时间点后面的数据。
* 默认情况下Redis在磁盘上创建二进制格式的命名为dump.rdb的数据快照，可以通过配置文件配置每隔N秒且数据集上至少有M个变化时创建快照，还可以配置是否对数据进行压缩、快照名称、存放快照的工作目录。

### AOF持久化
* AOF是以协议文本的方式，将所有对数据库进行过写入的命令（及其参数）记录到 AOF 文件，以此达到记录数据库状态的目的。
* 优点是基本可以实现数据无丢失（缓存的数据有可能丢失），缺点是随着数据量的持续增加，AOF文件也会越来越大。
