# 栈（Stack）和队列（Queue）

## 栈（Stack）
* 栈是一个元素集合，是一种后进先出的数据结构（LIFO），支持两种基本操作：push用于将元素压入栈，pop用于删除栈顶元素。
* 时间复杂度
    * 索引：O(n)
    * 查找：O(n)
    * 插入：O(1)
    * 删除：O(1)

## 队列（Queue）
* 队列是一个元素集合，是一种先进先出的数据结构（FIFO），支持两种基本操作：enqueue用于添加一个元素到队列，dequeue用于删除队列中的一个元素。
* 时间复杂度
    * 索引：O(n)
    * 查找：O(n)
    * 插入：O(1)
    * 删除：O(1)

## 常见应用

### 一个数组实现两个栈
* 算法一：将数组的两头分别作为两个栈的栈顶指针，插入数据时向中间靠拢，指针相遇说明空间已满，需对数组进行扩容。
* 算法二：将数组的中间两个数据位置分别作为两个栈的栈顶指针，插入数据时向两边走，其中有一个指针走到边界说明空间已满，则需对数组进行扩容。（缺点：有极端情况，一个栈满了但另一个栈很空，仍需扩容，空间利用率低）
* 算法三：将数组的奇偶位置分别作为两个栈的栈顶指针，插入数据时各自向前走， 其中有一个指针走到右边界说明空间已满，则需对数组进行扩容。（缺点：有极端情况，一个栈满了但另一个栈很空，仍需扩容，空间利用率低）

### 两个栈实现一个队列
* 入队时直接压入栈A；出队时先把栈A的所有元素依次出栈后压入栈B，此时栈B的顶部就是原先栈A的底部元素，即队列要求出队的元素。
* 出队操作后如果还要入队，则还要把栈B的所有元素依次出栈后压入栈A，即还原栈A。

### 两个队列实现一个栈
* 压栈时直接入队A；出栈时，把队A的元素依次出队后入队B，除了最后一个元素。
* 最后一个元素就是出栈要求的那个元素，将它返回即可。
* 出栈一次后，栈A和栈B的代号互换（栈A变为栈B，栈B变为栈A）。

### 实现一个栈，使其入栈、出栈、获取最小元素三个操作的时间复杂度均为O(1)
* 维护两个栈，分别称为S和Min，S用来进行正常的栈操作，Min用来存放最小元素。
    * 入栈：先入S栈，然后比较新元素和Min栈顶的元素，如果新元素小于Min栈顶的元素，则入Min栈。
    * 出栈：先出S栈，如果要出栈的元素在Min栈的栈顶，则也需要把Min栈的栈顶元素出栈。
    * 获取最小元素：获取Min栈顶的元素。
* 类似地，也可以实现最大元素栈。

### 排序栈s1中元素，只能使用一个额外的辅助栈s2
1. s1中的第一个栈顶元素直接弹出到s2中，因为一个元素不需要考虑顺序问题；
2. 当s1非空时，每次弹出一个栈顶元素保存在临时变量temp中，将s2中小于temp全部弹出到s1中；
3. temp入栈s2；
4. 把第(2)步中从s2弹出到s1中的所有元素再返回到s2，实际上这一步可以省略，因为s2新的栈顶比这几个元素都要大，因此s1现在的栈顶至少包括这几个元素比新栈顶小，根据第(2)步的判断也会同样弹回s2中。
5. 重复以上(2)-(4)步，直到s1为空时，所有元素在s2中已经完成了降序排列，弹回s1即完成了升序排列。


