# 数组（Array）和链表（LinkedList）

## 数组（Array）
* 数组是一个线性元素集合，每个元素有自己的序号。
* 时间复杂度
    * 索引：O(1)
    * 查找：O(1)
    * 插入：O(1) 或 O(n)
    * 删除：O(1) 或 O(n)

## 链表（LinkedList）
* 链表是一种由节点（Node）组成的线性数据集合，每个节点通过指针指向下一个节点。它是一种由节点组成，并能用于表示序列的数据结构。
    * 单链表：每个节点仅指向下一个节点，最后一个节点指向null。
    * 双链表：每个节点有两个指针，一个指针指向前一个节点，另一个指针指向下一个节点；第一个节点的前指针和最后一个节点的后指针指向null。
    * 循环链表：每个节点指向下一个节点，最后一个节点指向第一个节点。
* 时间复杂度：
    * 索引：O(n)
    * 查找：O(n)
    * 插入：O(1)
    * 删除：O(1)

## 常见应用

### 单链表反转并倒序输出
* 从后到前遍历并修改指针和输出元素。
* 使用递归或栈来实现。

### 合并两个有序的单链表成为一个新的有序单链表
1. 维护两个指针分别指向原先的两个链表，初始指向两个链表头。维护一个指针指向新链表的尾部。
2. 比较两个指针指向的项，取出其中较小（大）的一个放入新链表，相应指针往后移动。
3. 当其中一个指针走到结尾时，直接把另一个指针剩下未处理的元素全部添加到新链表的尾部。

### 找出单链表指定位置的元素
* 倒数第K个元素：快指针比慢指针先走K步，然后快慢指针每次各走一步。快指针走到结尾时，慢指针就指向倒数第K个元素。
* 中间元素：快指针每次走两步，慢指针每次走一步。快指针走到结尾时，慢指针就指向中间元素。

### O(1)时间复杂度删除节点
* 题目：给定头节点和指定节点，要求删除这个节点。
* 思路：把要删除的节点的下一个节点的值移动到要删除的节点上，然后把下一个节点删除。

### O(1)时间复杂度添加节点
* 题目：给定新节点和指定节点，要求把新节点插入到指定节点之前。
* 思路：把新节点和指定节点的值交换，题目就转换成把新节点插入到指定节点之后。

### 单链表中的环
* 判断是否有环：慢指针每次走一步，快指针每次走两步。如存在环，则两者相遇；如不存在环，快指针走到结尾时退出。
* 计算环的长度：从快慢指针的相遇点开始，绕着环走一圈，再次走到相遇点的位置时，所走过的结点数就是环的长度。
* 找出环的入口：两个指针分别从相遇点和起点开始走，再次相遇的点就是环的入口。
* 以上问题也可以用Hash法解决，以空间换时间。

### 两个单链表相交问题
* 两个单链表都没有环：
    * 方法一：暴力遍历两个链表。
    * 方法二：先遍历第一个链表，建立哈希表，再遍历第二个链表，判断每个节点地址哈希值是否和第一个表中的节点地址值有相同，即可判断两个链表是否相交，相同的点就是相交的点。
    * 方法三：先遍历第一个链表到其尾部，然后将尾部的原本指向NULL的next指针指向第二个链表头，这样两个链表就合成了一个链表，问题就转变为判断新的链表是否有环，环的入口就是相交的点。
    * 方法四：一旦两个链表相交，那么两个链表从相交节点开始到尾节点一定都是相同的节点。所以，如果他们相交的话，那么他们最后的一个节点一定是相同的，因此分别遍历到两个链表的尾部，然后判断两个尾节点是否相同。
* 一个有环一个没有：肯定不相交。
* 两个单链表都有环：
    * 不相交：两个链表有各自的环。
    * 相交的点在环内（包括环入口）：交点为两个链表的环入口，所以只需要找到两个链表的环的入口就可以了。
    * 相交的点在环外：计算出两个链表的长度之差，记为K，然后让长链表的指针先走K步，短链表的指针再开始走，这样他们一定同时到达第一个公共节点。只需要在向后移动的时候比较两个链表的节点是否相等就可以获得第一个公共节点。

