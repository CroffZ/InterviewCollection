# 软件设计

## 内聚与耦合

### 模块的概念
模块是一系列语句组成的，由标识符组成的边界元素来界定的。比如面向对象语言中的一个类、一个方法；也如面向过程中的函数。

### 内聚
内聚是指模块内的交互程度，以下几种内聚程度由低到高。

* 偶然内聚：组件的部件是不相关的，只是简单地绑定成单个组件。
* 逻辑内聚：把相似的功能（类如输入，错误处理）放在一块，通过传递一个参数来决定是哪一个功能来执行。
* 时间内聚：所有的语句在同一时刻被激活，就像电脑关机的时候，其他所有的程序都要被关闭。
* 过程内聚：简单地把一系列过程关联在一起。
* 通信内聚：操作相同的输入数据或者输出相同的输出数据，可能产生多种功能。
* 顺序内聚：用一个部分的输出作为另一部分的输入，可能包含几个功能或部分不同的功能。
* 信息内聚：执行多个功能，每个函数都有自己的入口点，每个函数都有独立的代码，所有的功能都在相同的数据结构上执行。不同于逻辑衔接，因为功能没有交织在一起。
* 功能内聚：每一部分都需要执行一个单一的功能。例如，计算平方根或排序数组。

### 耦合
耦合是指模块之间的交互程度，以下几种耦合程度由高到低。

* 内容耦合：一个模块直接操作操作另外一个模块中的内容。
* 公共耦合：就像一个类中的全局变量类中的模块都直接操作这个全局变量。
* 控制耦合：通过控制标志（作为参数或变量），一个模块控制另一个模块的处理步骤的顺序。
* 印记耦合：一组模块通过参数表传递记录信息，这组模块共享了这个记录，它是某一数据结构的子结构，而不是简单变量。这要求这些模块都必须清楚该记录的结构，并按结构要求对此记录进行操作。
* 数据耦合：如果一个模块访问另一个模块时，彼此之间是通过数据参数（不是控制参数、公共数据结构或外部变量）来交换输入、输出信息的，则称这种耦合为数据耦合。

## 设计原则

### 开闭原则（Open-Closed Principle，OCP）
* 一个软件实体应当对扩展开放，对修改关闭。因为客户的需求是不稳定的，我们应该通过扩展已有的软件系统而不是通过修改软件系统来满足客户的需求。
* 具体表现为已有的模块，特别是抽象层的模块不能修改，保证软件系统的稳定性和延续性。
* 实现开闭原则的关键是抽象化，在面向对象的编程语言里，可以给系统定义出一套相对较为固定的抽象设计，此设计允许无穷无尽的行为在实现层被实现。
* 在语言里，可以给出一个或多个抽象类或者接口，规定出所有的具体类必须提供的方法的特征作为系统设计的抽象层。这个抽象层预见了所有的可扩展性，因此，在任何扩展情况下都不会改变。这就使得系统的抽象不需要修改，从而满足了开闭原则的第二条，对修改关闭。同时，由于从抽象层导出一个或多个新的具体类可以改变系统的行为，因此系统的设计对扩展是开放的，这就满足了开闭原则的第一条。

### 里氏代换原则（Liskov Substitution Principle，LSP）
* 子类型必须能够替换它们的基类型，而反过来的代换则不成立。
* 当两个具体类关系违反里氏代换原则时，有两种解决方法：
    * 一种是抽象出一个基类，作为这两个类的父类；
    * 另一种是建立组合或聚合关系。
* 不要为了使用某些类的方法（功能）而滥用继承。

### 依赖倒置原则(Dependence Inversion Principle，DIP)
* 具体要依赖于抽象，而不是抽象依赖于具体。
* 要针对接口编程，不要针对实现编程。同样，在处理类之间的耦合关系时，尽量使用抽象耦合的形式。
* 里氏替换原则是依赖倒转原则的基础。工厂模式、模板模式、迭代子模式都是对依赖倒转原则的体现。

### 接口隔离原则（Interface Segregation Principle，ISP）
* 使用多个专门的接口而不使用单一的总接口。换而言之，一个类对另外一个类的依赖性应当是建立在最小接口上的。
* 过于臃肿的接口是对接口的污染，不应该强迫客户依赖于它们不用的方法，每一个接口应该是一种角色，不多不少，不干不该干的事，该干的事都要干。
* 为同一个角色提供宽、窄不同的接口，以应对不同类的需求。

### 合成/聚合复用原则（Composite/Aggregate Reuse Principle，CARP）
* 就是在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分，新对象通过向这些对象的委派达到复用已有功能的目的。
* 简而言之，要尽量使用合成/聚合，而尽量不要使用继承。
* 要区分has a和is a的问题。

### 迪米特法则（Law of Demeter，LoD）
* 只与直接的朋友们通信，而不要和陌生人说话。
* 如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中的一个类需要调用另外一个类的某一个方法，可以通过第三者转发这个调用。

## 设计模式

### 单例模式（Singleton）
在Java中，单例模式能保证在JVM中只存在一个单例对象的实例，有如下几种实现方法：

#### 饿汉式
```java
public final class Singleton {
    private static Singleton instance = new Singleton();
    private Singleton() {}
    public static Singleton getInstance() {
        return instance;
    }
}
```

* 每个对象在没有使用之前就已经初始化了。
* 带来性能问题：当对象很大时，在没有使用它之前，就把它加载到内存中，浪费内存空间。

#### 懒汉式
```java
public final class Singleton {
    private static Singleton instance;
    private Singleton() {}
    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

* 使用延迟加载来保证对象在没有使用之前不会初始化。
* 线程不安全，因为在多个线程可能同时运行到判断instance为null，于是同时初始化。

#### 懒汉式 + synchronized
```java
public final class Singleton {
    private static Singleton instance;
    private Singleton() {}
    public static synchronized Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

* getInstance()方法加同步锁，解决线程安全问题。
* 性能问题：同步的代价必然会一定程度地降低程序并发度。

#### 双重检查锁
```java
public final class Singleton {
    private static Singleton instance;
    private Singleton() {}
    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

* 这种写法在解决线程安全问题的同时，保证了程序并发度。

### 工厂模式（Factory）
建立一个工厂类，对实现了同一接口的一些类进行实例化。

#### 简单工厂模式
* 普通工厂方法模式：先实例化工厂类，再调用工厂对象的创建方法，将类名字符串作为参数传入，返回值就是创建好的对象。
* 多个工厂方法模式：在普通工厂方法模式中，如果传递的字符串参数出错，则不能正确创建对象，而多个工厂方法模式是提供多个工厂方法，分别对应不同对象的创建。
* 使用静态方法：将多个工厂方法模式里的方法都改为静态的，不需要创建工厂实例，直接调用工厂类的静态方法即可。

#### 工厂方法模式
* 简单工厂模式有一个问题：类的创建依赖于工厂类，也就是说，如果想要拓展程序，必须对工厂类进行修改，违背了闭包原则。
* 工厂方法模式是指，创建一个工厂接口和创建多个工厂实现类，这样一旦需要增加新的功能，直接增加新的工厂实现类，而不需要修改之前的代码。

#### 抽象工厂模式
* 抽象工厂模式是工厂方法模式的一种升级，它提供一个接口，可以创建一个对象集合，这个集合中的对象组合起来可以实现特定功能，该接口可以有多种实现。
* 工厂方法模式和抽象工厂模式的区别：工厂方法模式是针对一个抽象产品类来生产对应的对象，而抽象工厂模式是针对多个抽象产品类来生产对应的对象集合。


