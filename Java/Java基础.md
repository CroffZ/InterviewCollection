# Java基础

## 面向对象编程（OOP）
* 抽象：将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。
* 封装：把属性和方法绑定起来，只能通过已定义的接口访问对象，并对外隐藏内部的具体实现。
* 继承：从父类继承指定的属性和方法，提供了代码的重用行，也可以在不修改类的情况下给现存的类添加新特性。
* 多态：简单来说就是用同样的对象引用调用同样的方法但是做了不同的事情，分为编译时的多态性和运行时的多态性。方法重载（Overloading）实现的是编译时的多态性；方法重写（Overriding）实现的是运行时的多态性。

## 方法重载（Overloading）和方法重写（Overriding）
* 方法重载（Overloading）：发生在同一个类里面两个或者是多个方法的方法名相同但是参数不同的情况。
* 方法重写（Overriding）：是说子类重新定义了父类的方法。方法覆盖必须有相同的方法名，参数列表和返回类型。

## JDK、JRE、JVM
* JDK（Java Development Kit）：Java开发工具包，包括JRE、编译器和其他的工具（如JavaDoc和Java调试器），可以让开发者开发、编译、执行Java应用程序。
* JRE（Java Runtime Environment）：Java运行环境，包括Java虚拟机和执行Applet需要的浏览器插件。
* JVM（Java Virtual Machine）：Java虚拟机，是一个可以执行Java字节码的虚拟机进程，它知道底层硬件平台的指令长度和其他特性，所以Java拥有跨平台特性。

## static关键字
* static关键字表示一个成员变量或成员方法可以在没有所属的类的实例变量的情况下被访问。
* static方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的，所以static方法跟类的任何实例都不相关。
* static变量也称为类变量，它属于类，不属于类的任何一个实例对象，因此一个类不管创建多少个对象，静态变量在内存中有且仅有一个拷贝。当类被Java虚拟机载入的时候，会对static变量进行初始化。

## 类的实例化顺序
1. 父类static变量、代码块
2. 子类static变量、代码块
3. 父类非static成员变量
4. 子类非static成员变量
5. 父类构造方法
6. 子类构造方法

## Java的数据类型
* Java中的数据类型有三种：基本类型（Primitive Type）、枚举类型（Enumeration Type）和引用类型（Reference Type）。基本数据类型有八种：byte、short、int、long、float、double、boolean、char。
* 自动拆／装箱：Java编译器在基本数据类型和对应的对象包装类型之间做的一个转化。比如：自动装箱是把int转化成Integer，double转化成Double，等等。反之就是自动拆箱。
* String不是基本数据类型，它由final修饰，所以也不能被继承。
* char类型可以存储一个中文汉字，因为Java中使用的编码是Unicode，一个char类型占2个字节，所以放一个中文是没问题的。

## String为什么是不可变类
* String类是final的，它的主力成员字段value也是一个final的char[]，因此String创建之后就不能再修改。
* 字符串放进常量池存储可以节省很多堆空间，而只有字符串是不可变的时候，才能把字符串放进常量池，因为如果字符串改变了值，其他所有指向该字符串的值都会改变。
* 字符串创建的时候，它的HashCode就被缓存了，不需要重新计算，所以它很适合作为Map中的key，同理其他不可变类如Integer也同样适合用作Map中的key。
* 不可变意味着字符串是线程安全的，可以避免使用同步，而且也可以避免其他安全问题，因为字符串常常被当作很多重要参数，如URL、文件路径，还有反射机制需要的字符串参数等，如果字符串可变的话会存在安全隐患，比如在一个线程内已经检查过字符串的值后准备拿来用了，但另一个线程在用之前把它改掉了，会导致安全问题。

## String、StringBuilder和StringBuffer
* 每次操作字符串，String会产生一个新的对象，而StringBuilder和StringBuffer不会。这是因为String中的char数组是final的，不可修改；而StringBuilder和StringBuffer中的char数组不是final的，可以修改。
* StringBuffer是线程安全的（使用synchronized），而StringBuilder不是。

## 访问权限修饰符
| 修饰符 | 当前类 | 同包类 | 子类 | 所有类 |
| --- | --- | --- | --- | --- |
| public | 可以访问 | 可以访问 | 可以访问 | 可以访问 |
| protected | 可以访问 | 可以访问 | 可以访问 | 不能访问 |
| default | 可以访问 | 可以访问 | 不能访问 | 不能访问 |
| private | 可以访问 | 不能访问 | 不能访问 | 不能访问 |

## 抽象类和接口
* 接口中所有方法都是抽象的，而抽象类可以同时包含抽象和非抽象的方法。
* 类可以实现很多个接口，但是只能继承一个抽象类。
* 类如果要实现一个接口，它必须要实现接口声明的所有方法，但是类可以不实现抽象类声明的所有方法而声明成是抽象的。
* 接口中变量默认是final的，抽象类可以包含非final的变量。
* 接口中成员函数默认是public的，抽象类的成员函数可以是private、protected或public。

## 值传递和引用传递
* 对象被值传递，意味着传递了对象的一个副本。因此，就算是改变了对象副本，也不会影响源对象的值。
* 对象被引用传递，意味着传递的并不是实际的对象，而是对象的引用。因此，外部对引用对象所做的改变会反映到所有的对象上。

## 异常处理
* Java中有两种异常：Unchecked异常和Checked异常。Unchecked异常继承自java.lang.RuntimeException类，Checked异常继承java.lang.Exception类。Checked异常必须被显式地捕获（try-catch-finally）或者传递（throws）。
* throw用来在代码中抛出一个异常，throws用来表明方法不能处理的异常／可能抛出的异常。
* 无论是否抛出异常，finally代码块总是会被执行。就算是没有catch语句同时又抛出异常的情况下，finally代码块仍然会被执行。finally代码块主要用来释放资源，比如：数据库连接。
* 异常处理完成以后，Exception对象会在下一个垃圾回收周期中被回收掉。

## try-catch-finally带return的执行顺序
* 无异常的情况：先执行try块中除了return操作外的代码，再执行finally块中的所有代码，如果finally块包含return则直接返回，如果没有则回到try块中的return操作执行返回。
* 有异常的情况：执行到try块中出现异常的位置后，执行catch块中除了return操作外的代码，再执行finally块中的所有代码，如果finally块包含return则直接返回，如果没有则回到catch块中的return操作执行返回。

## Java中的I/O

### BIO、NIO和AIO
* BIO：Blocking I/O，同步阻塞I/O。用户发起一个I/O操作时，必须阻塞等待I/O操作完成，在此期间不能做其他工作。
* NIO：New I/O或Non-blocking I/O，同步非阻塞I/O。用户发起一个I/O操作后可以同时做其他工作，但是需要不停询问这个I/O操作是否完成，会导致不必要的CPU资源浪费。
* AIO：Asynchronous I/O，异步I/O。用户只需要发起I/O操作然后立即返回，等I/O操作完成后会得到通知，而不需要等待或不停询问。

### NIO核心部分
* 通道Channel：跟I/O中的流（Stream）差不多，不过Stream是单向的，如InputStream和OutputStream，而Channel是双向的，既可读也可写，主要实现有FileChannel、DatagramChannel、SocketChannel和ServerSocketChannel。
* 缓冲区Buffer：一个Buffer对象是固定数量的数据的容器，在这里数据可被存储并在之后用于检索。NIO中的关键Buffer是ByteBuffer，包括MappedByteBuffer、HeapByteBuffer、DirectByteBuffer等，除此之外也有其他基本数据类型的Buffer。
* 选择器Seletor：是NIO相对于BIO实现多路复用的基础，Seletor可以运行单线程处理多个Channel。使用Seletor时，先向Seletor注册Channel，然后调用select()方法，这个方法会一直阻塞到某个注册的Channel有事件就绪，一旦这个方法返回，线程就可以处理这些事件，事件的例子包括收到新连接请求、数据接收等。

### I/O设计模式
* Reactor模式：用户定义的操作是在I/O操作之前被调用的，比如你定义了一个操作要向socket写入数据，当这个socket可以接收数据时，你的操作就会被调用。主要用于同步I/O。
* Proactor模式：用户定义的操作是在I/O操作之后被调用的，比如你定义了一个操作要显示从socket中读出的数据，当这个socket的读操作完成后，你的操作才会被调用。主要用于异步I/O。
* 两种模式的比较（来自知乎）：
    * Reactor模式：能收数据了跟俺说一声。
    * Proactor模式：你给俺收十个字节，收好了跟俺说一声。

## Java反射机制
* 概念：在运行状态中，使用反射机制可以获取任意一个类或实例对象的所有属性和方法（包括private），也可以调用它的任意一个方法（包括private）。
* 用途：程序运行时，不能一次性把所有的类都加载到JVM，而是用到的时候再加载，可以节省永久代的内存，这种情况可以使用反射机制。
* 实现：首先获取该类的字节码文件，然后解析其中的数据内容，构造成一个Class类型的对象，将其放入永久代。

## Java与C++的比较
* 数据类型：Java是强类型语言，具有平台无关性，即在不同平台上占用的存储空间是一样的。
* 字符串：Java的字符串封装了很多好用的方法，C++得用char*。
* 指针：Java不用指针，而是用引用，避免了很多错误。
* 操作内存：Java不能直接操作内存，由JVM代为管理，提高开发效率；而C++可以由程序员自由操作内存，比如程序员可以手动申请和释放内存空间，所以C++更适用于偏向系统底层的开发。
* 面向对象：Java是完全面向对象的语言，而C++从C语言继承了面向过程的编程，它既可以面向过程也可以面向对象。
* 参数：Java中方法调用的参数如果是基本数据类型则为值传递，如果是对象则为引用传递。
* 跨平台：Java可以实现一次编译到处运行，实现的基础是JVM虚拟机，所以也被诟病效率差速度慢，但实际上JVM这些年已经做了很多优化，包括GC和编译执行（JIT编译器和AOT静态编译的优化），JVM虚拟机已经不像从前那么慢了，也可以开始在游戏等领域上使用Java开发来提高开发效率降低成本了。

## Java和其他语言的比较
* Python：一款弱类型解释型开源脚本语言，被称为胶水语言因为它可以很好地与其他语言合作开发，语法简单，社区活跃，现成的库很多，不需要重复造轮子。
* C#：微软看到Java太火了就发明了一个跟Java语法差不多的语言叫C#，全面集成.NET库，不过也因为这样造成跨平台能力差。
* JavaScript：一种动态类型、弱类型、基于原型的脚本语言，简单易学，社区活跃，常用于给网页添加动态功能，也可以用NodeJS来开发服务器。
* Swift：iOS和macOS开发常用语言，苹果在2014年WWDC上发布，有丰富的工具和库，开源社区也比较活跃，但是版本更新很快，而且有时候新版本改动很大，几乎相当于重新学一门新语言，所以有”从精通到重新入门”说法。但这两年似乎逐渐稳定了，尤其是Swift3到Swift4可以无缝对接，不至于像以前一样更新编译器版本号之后满屏幕的报错。
* PHP：一种通用开源脚本语言，易于学习，使用广泛，主要用于Web开发，号称世界上最好的语言。

