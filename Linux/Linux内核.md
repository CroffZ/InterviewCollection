# Linux内核

## 进程

### fork进程的操作
* 调用fork创建的子进程，将共享父进程的代码空间，复制父进程数据空间，此时子进程会获得父进程的所有变量的一份拷贝。
* fork()返回值意义如下：
    * =0：在子进程中，表示当前进程是子进程。
    * >0：在父进程中，返回值为子进程的id值（唯一标识号）。
    * -1：创建失败。
* fork的特点是：一次调用，两次返回。

### 父子进程、孤儿进程和僵尸进程
* 通过fork函数创建的新进程是原进程的子进程，而调用fork函数的进程是fork函数创建出来的新进程的父进程。也就是说，通过fork函数创建的新进程与原进程是父子关系，fork就相当于一个凭证，有fork，就有父子关系。
* 当父进程结束了而子进程未结束时，子进程就变成了孤儿进程，交由init进程管理。init进程是一个守护进程，在大多数Linux系统中init进程的pid为1，不过Ubuntu为了减轻pid为1进程的压力，将其内核修改过，所以Ubuntu中的init进程pid不为1。因为init进程管理了很多孤儿进程，所以也称之为进程的孤儿院。
* Unix提供了一种机制：在每个进程退出的时候，内核释放该进程所有的资源，但是仍然为其保留一定的信息（包括pid、退出状态、运行时间等），直到父进程通过wait/waitpid来取时才释放。但这样就导致了问题，如果父进程不调用wait/waitpid的话，那么保留的那段信息就不会释放，其进程号就会一直被占用，这就是僵尸进程。但是系统所能使用的进程号是有限的，如果产生了大量僵尸进程，就会因为没有可用的进程号而导致系统不能产生新的进程。
* 任何一个子进程（init除外）在exit()之后，并非马上就消失掉，而是留下一个称为僵尸进程的数据结构，等待父进程处理。这是每个子进程在结束时都要经过的阶段。
* 父进程死后，僵尸进程会变成孤儿进程，过继给init进程，init进程始终会负责清理僵尸进程，它产生的所有僵尸进程也跟着消失。

### fork和vfork的区别
* fork要拷贝父进程的数据段；而vfork则不需要完全拷贝父进程的数据段。在子进程没有调用exec和exit之前，子进程与父进程共享数据段。
* fork不限制父子进程的执行次序；而vfork调用时，子进程先运行，父进程挂起，直到子进程调用了exec或exit之后，父子进程的执行次序才不再有限制。

## 信号（Signal）

### 概念
* 信号是系统中对进程的通知。比如控制台中按Ctrl+C可以停下当前正在执行的进程，还有kill命令可以强制中止对应pid的进程。
* 是Linux下处理异步事件的一种方式，名称全部以SIG开头。
* 本质上是一种软中断。

### 信号的产生
* 终端特殊按键：Ctrl+C（SIGINT）
* 硬件异常中断信号，如内存错误（SIGSEGV）
* kill(1)
* kill(2)

### Linux中的信号

### Signal信号的可靠性
* 不一定每个信号都能被捕捉到。
* 信号不会被阻塞，如果发信号时系统刚好卡了一下，信号就会被卡没了。
* 信号处理有自动复位机制。避免方法：在信号处理函数中再注册一次自身。但是这样仍然是不可靠的，原因是进入处理函数到重新注册之间有时间差，在这段时间差内的信号不会被信号处理函数捕捉到并处理。

